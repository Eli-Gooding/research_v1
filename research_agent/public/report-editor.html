<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Research Report Editor</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1, h2, h3 {
      color: #2c3e50;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .url-form {
      background-color: #f8f9fa;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .url-input {
      width: 70%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
    }
    
    .submit-button {
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    
    .submit-button:hover {
      background-color: #0069d9;
    }
    
    .status-container {
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    
    .editor-container {
      display: flex;
      gap: 20px;
    }
    
    .editor-main {
      flex: 3;
    }
    
    .editor-sidebar {
      flex: 1;
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
    }
    
    #editor {
      width: 100%;
      height: 500px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
    }
    
    .status-bar {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
    }
    
    .status-indicator {
      display: flex;
      align-items: center;
    }
    
    .status-indicator::before {
      content: '';
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }
    
    .status-connected::before {
      background-color: #28a745;
    }
    
    .status-disconnected::before {
      background-color: #dc3545;
    }
    
    .users-list {
      margin-top: 20px;
    }
    
    .users-list ul {
      list-style-type: none;
      padding: 0;
    }
    
    .users-list li {
      padding: 8px 0;
      border-bottom: 1px solid #eee;
    }
    
    .status-active {
      color: #28a745;
    }
    
    .status-idle {
      color: #ffc107;
    }
    
    .status-offline {
      color: #6c757d;
    }
    
    .button {
      padding: 8px 16px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .button:hover {
      background-color: #0069d9;
    }
    
    .hidden {
      display: none;
    }

    .api-url-form {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 5px;
    }

    .api-url-input {
      width: 70%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
      margin-right: 10px;
    }
    
    .mode-selector {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .mode-button {
      flex: 1;
      padding: 15px;
      text-align: center;
      background-color: #f8f9fa;
      border: 1px solid #ddd;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .mode-button:hover {
      background-color: #e9ecef;
    }
    
    .mode-button.active {
      background-color: #007bff;
      color: white;
      border-color: #007bff;
    }
    
    .mode-button h3 {
      margin-top: 0;
      color: inherit;
    }
  </style>
</head>
<body>
  <h1>Research Report Editor</h1>
  
  <div class="container">
    <div class="mode-selector">
      <div id="standalone-mode-button" class="mode-button active">
        <h3>Standalone Editor</h3>
        <p>Use the collaborative editor without connecting to the API</p>
      </div>
      <div id="api-mode-button" class="mode-button">
        <h3>API Integration</h3>
        <p>Generate reports from websites using the Cloudflare Workers API</p>
      </div>
    </div>
    
    <div id="api-settings" class="api-url-form hidden">
      <h3>API Configuration</h3>
      <p>Enter the URL of your Cloudflare Workers API:</p>
      <input type="url" id="api-url-input" class="api-url-input" placeholder="Enter API URL (e.g., http://localhost:8787)" value="http://localhost:8787">
      <button id="save-api-url" class="button">Save</button>
    </div>

    <div id="url-form-container" class="url-form hidden">
      <h2>Generate a New Report</h2>
      <form id="scrape-form">
        <input type="url" id="url-input" class="url-input" placeholder="Enter website URL (e.g., https://example.com)" required>
        <button type="submit" class="submit-button">Generate Report</button>
      </form>
    </div>
    
    <div id="status-container" class="status-container hidden">
      <h3>Report Status</h3>
      <div id="status-message">Initializing...</div>
      <div id="progress-bar" style="margin-top: 10px; height: 20px; background-color: #eee; border-radius: 4px; overflow: hidden;">
        <div id="progress" style="height: 100%; width: 0%; background-color: #007bff; transition: width 0.3s;"></div>
      </div>
    </div>
    
    <div id="editor-section">
      <h2>Collaborative Report Editor</h2>
      <p>This report can be edited by multiple users simultaneously. Changes are saved automatically.</p>
      
      <div class="editor-container">
        <div class="editor-main">
          <textarea id="editor" placeholder="Report content will appear here..."></textarea>
          
          <div class="status-bar">
            <div class="status-indicator" id="status-indicator">
              <span id="status">Connecting...</span>
            </div>
            
            <button class="button" id="save-button">Save Report</button>
            <button class="button" id="toggle-debug-button">Show Raw JSON</button>
          </div>
          
          <!-- Debug section to show raw JSON -->
          <div id="debug-section" style="display: none; margin-top: 20px;">
            <h3>Raw JSON Response</h3>
            <pre id="raw-json" style="background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow: auto; max-height: 300px; font-family: monospace; font-size: 12px;"></pre>
          </div>
        </div>
        
        <div class="editor-sidebar">
          <h3>Connected Users</h3>
          <div class="users-list" id="users">
            <div>No other users connected</div>
          </div>
          
          <div style="margin-top: 30px;">
            <h3>Report Information</h3>
            <div id="report-info">
              <p><strong>URL:</strong> <span id="report-url">-</span></p>
              <p><strong>Generated:</strong> <span id="report-date">-</span></p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script src="/js/document-editor.js"></script>
  <script>
    // Main application logic
    document.addEventListener('DOMContentLoaded', () => {
      // DOM elements
      const standaloneButton = document.getElementById('standalone-mode-button');
      const apiButton = document.getElementById('api-mode-button');
      const apiSettings = document.getElementById('api-settings');
      const urlFormContainer = document.getElementById('url-form-container');
      const apiUrlInput = document.getElementById('api-url-input');
      const saveApiUrlButton = document.getElementById('save-api-url');
      const scrapeForm = document.getElementById('scrape-form');
      const urlInput = document.getElementById('url-input');
      const statusContainer = document.getElementById('status-container');
      const statusMessage = document.getElementById('status-message');
      const progressBar = document.getElementById('progress');
      const editorSection = document.getElementById('editor-section');
      const reportUrl = document.getElementById('report-url');
      const reportDate = document.getElementById('report-date');
      const saveButton = document.getElementById('save-button');
      const toggleDebugButton = document.getElementById('toggle-debug-button');
      
      let currentTaskId = null;
      let statusCheckInterval = null;
      let apiBaseUrl = localStorage.getItem('apiBaseUrl') || 'http://localhost:8787';
      let reportData = null; // Store the report data globally for debugging
      
      // Initialize API URL input
      apiUrlInput.value = apiBaseUrl;
      
      // Mode selection
      standaloneButton.addEventListener('click', () => {
        standaloneButton.classList.add('active');
        apiButton.classList.remove('active');
        apiSettings.classList.add('hidden');
        urlFormContainer.classList.add('hidden');
        statusContainer.classList.add('hidden');
        
        // Initialize standalone mode
        initStandaloneMode();
      });
      
      apiButton.addEventListener('click', () => {
        apiButton.classList.add('active');
        standaloneButton.classList.remove('active');
        apiSettings.classList.remove('hidden');
        urlFormContainer.classList.remove('hidden');
      });
      
      // Initialize in standalone mode by default
      initStandaloneMode();
      
      // Save API URL
      saveApiUrlButton.addEventListener('click', () => {
        apiBaseUrl = apiUrlInput.value.trim();
        if (apiBaseUrl) {
          localStorage.setItem('apiBaseUrl', apiBaseUrl);
          alert('API URL saved successfully!');
        }
      });
      
      // Initialize standalone mode
      function initStandaloneMode() {
        // Update report info
        reportUrl.textContent = 'Standalone Mode';
        reportDate.textContent = new Date().toLocaleString();
        
        // Set default content
        const defaultContent = `# Collaborative Document Editor

This is a standalone collaborative editor powered by PartyKit. You can edit this document and collaborate with others in real-time.

## How to use

1. Edit this document
2. Share the URL with others
3. See changes in real-time

## Features

- Real-time collaboration
- Multiple users can edit simultaneously
- Changes are saved automatically
- No account required

## Tips

- You can use Markdown formatting in this editor
- Use # for headings, * for bullet points, etc.
- The editor will automatically save your changes

`;
        
        // Set the editor content directly first
        document.getElementById('editor').value = defaultContent;
        
        // Then try to initialize the collaborative editor
        try {
          if (window.documentEditor) {
            window.documentEditor.setContent(defaultContent);
          } else {
            // If the document editor isn't initialized yet, try to initialize it
            setTimeout(() => {
              if (window.documentEditor) {
                window.documentEditor.setContent(defaultContent);
              }
            }, 1000);
          }
          
          // Try to save to collaborative document
          try {
            fetch('/party/document', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ content: defaultContent })
            })
            .then(response => {
              if (response.ok) {
                console.log('Document saved successfully');
                document.getElementById('status').textContent = 'Connected';
                document.getElementById('status-indicator').classList.add('status-connected');
              } else {
                console.warn('Failed to save document');
                document.getElementById('status').textContent = 'Error saving document';
                document.getElementById('status-indicator').classList.add('status-disconnected');
              }
            })
            .catch(error => {
              console.warn('Error saving to collaborative document, but editor is still usable:', error);
              document.getElementById('status').textContent = 'Disconnected';
              document.getElementById('status-indicator').classList.add('status-disconnected');
            });
          } catch (error) {
            console.warn('Error saving to collaborative document, but editor is still usable:', error);
            document.getElementById('status').textContent = 'Disconnected';
            document.getElementById('status-indicator').classList.add('status-disconnected');
          }
        } catch (error) {
          console.warn('Error initializing collaborative editor, but basic editor is still usable:', error);
          document.getElementById('status').textContent = 'Disconnected';
          document.getElementById('status-indicator').classList.add('status-disconnected');
        }
      }
      
      // Handle form submission
      scrapeForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const url = urlInput.value.trim();
        if (!url) return;
        
        try {
          // Show status container
          statusContainer.classList.remove('hidden');
          statusMessage.textContent = 'Starting scraping process...';
          progressBar.style.width = '10%';
          
          // Log the request for debugging
          console.log(`Sending request to: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}`);
          console.log(`Request body: ${JSON.stringify({ action: 'scrape', url: url, targetUrl: url, timestamp: Date.now() })}`);
          
          // Submit URL for scraping through the proxy
          const response = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ action: 'scrape', url: url, targetUrl: url, timestamp: Date.now() })
          });
          
          // Log the response for debugging
          console.log(`Response status: ${response.status}`);
          const responseText = await response.text();
          console.log(`Response text: ${responseText}`);
          
          // Try to parse the response as JSON
          let data;
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            console.error('Error parsing response as JSON:', parseError);
            statusMessage.textContent = `Error: Failed to parse response as JSON. Raw response: ${responseText.substring(0, 100)}${responseText.length > 100 ? '...' : ''}`;
            return;
          }
          
          if (data.status === 'success' || data.status === 'queued') {
            // Use jobId if available, otherwise use taskId
            currentTaskId = data.jobId || data.taskId;
            statusMessage.textContent = 'Scraping in progress...';
            progressBar.style.width = '30%';
            
            console.log(`Task ID received: ${currentTaskId}`);
            
            // Start checking status
            startStatusChecking(currentTaskId);
          } else {
            statusMessage.textContent = `Error: ${data.error || 'Failed to start scraping process'}`;
          }
        } catch (error) {
          console.error('Error submitting URL:', error);
          statusMessage.textContent = `Error: Failed to communicate with the server. ${error.message || ''}. Make sure the API URL is correct.`;
        }
      });
      
      // Function to check task status
      function startStatusChecking(taskId) {
        // Clear any existing interval
        if (statusCheckInterval) {
          clearInterval(statusCheckInterval);
        }
        
        let checkCount = 0;
        const maxChecks = 20; // Maximum number of status checks (20 checks * 2 seconds = 40 seconds)
        
        statusCheckInterval = setInterval(async () => {
          try {
            checkCount++;
            // Updated URL format to match the worker's expected format
            console.log(`Checking task status: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=task-status&taskId=${taskId}`);
            
            const response = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=task-status&taskId=${taskId}`);
            
            console.log(`Task status response: ${response.status}`);
            const responseText = await response.text();
            console.log(`Task status response text: ${responseText.substring(0, 100)}${responseText.length > 100 ? '...' : ''}`);
            
            // Try to parse the response as JSON
            let taskData;
            try {
              taskData = JSON.parse(responseText);
            } catch (parseError) {
              console.error('Error parsing task status response as JSON:', parseError);
              statusMessage.textContent = `Error: Failed to parse task status response as JSON. Raw response: ${responseText.substring(0, 100)}${responseText.length > 100 ? '...' : ''}`;
              return;
            }
            
            // Update progress based on status
            if (taskData.status === 'completed' || taskData.status === 'success') {
              // Task completed, stop checking
              clearInterval(statusCheckInterval);
              statusMessage.textContent = 'Report generated successfully!';
              progressBar.style.width = '100%';
              
              // Load the report
              loadReport(taskId);
            } else if (taskData.status === 'error' || taskData.status === 'failed') {
              // Task failed
              clearInterval(statusCheckInterval);
              statusMessage.textContent = `Error: ${taskData.error || taskData.message || 'Unknown error occurred'}`;
              progressBar.style.width = '100%';
            } else if (taskData.status === 'processing' || taskData.status === 'analyzing') {
              // Task in progress with more specific status
              const progress = taskData.progress || Math.min(30 + (checkCount * 3), 95);
              statusMessage.textContent = `Status: ${taskData.status} - ${taskData.message || 'Processing...'} (${checkCount}/${maxChecks})`;
              progressBar.style.width = `${progress}%`;
            } else if (taskData.status === 'unknown') {
              // Worker returns unknown status - this might mean it's still processing
              // Calculate progress based on check count - slower progression for longer wait time
              const progress = Math.min(30 + (checkCount * 3), 95);
              statusMessage.textContent = `Status: Processing... (${checkCount}/${maxChecks})`;
              progressBar.style.width = `${progress}%`;
              
              // If we've checked enough times, assume it's done
              if (checkCount >= maxChecks) {
                clearInterval(statusCheckInterval);
                statusMessage.textContent = 'Assuming report is ready, attempting to load...';
                progressBar.style.width = '100%';
                
                // Try to load the report
                loadReport(taskId);
              }
            } else {
              // Task still in progress with generic status
              // Calculate progress based on check count
              const progress = Math.min(30 + (checkCount * 5), 95);
              statusMessage.textContent = `Status: ${taskData.status || 'In progress'} (${checkCount}/${maxChecks})`;
              progressBar.style.width = `${progress}%`;
              
              // If we've checked enough times, assume it's done
              if (checkCount >= maxChecks) {
                clearInterval(statusCheckInterval);
                statusMessage.textContent = 'Assuming report is ready, attempting to load...';
                progressBar.style.width = '100%';
                
                // Try to load the report
                loadReport(taskId);
              }
            }
          } catch (error) {
            console.error('Error checking task status:', error);
            statusMessage.textContent = `Error checking task status: ${error.message || 'Unknown error'}`;
            
            // If we've checked enough times, try to load the report anyway
            if (checkCount >= maxChecks) {
              clearInterval(statusCheckInterval);
              statusMessage.textContent = 'Assuming report is ready despite errors, attempting to load...';
              progressBar.style.width = '100%';
              
              // Try to load the report
              loadReport(taskId);
            }
          }
        }, 2000); // Check every 2 seconds
      }
      
      // Function to load the report
      async function loadReport(taskId) {
        try {
          // First try the standard report endpoint with the detailed report ID format
          console.log(`Loading report: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=report&reportId=${taskId}-detailed`);
          
          const response = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=report&reportId=${taskId}-detailed`);
          
          console.log(`Report response status: ${response.status}`);
          const responseText = await response.text();
          console.log(`Report response text: ${responseText.substring(0, 100)}${responseText.length > 100 ? '...' : ''}`);
          
          // Try to parse the response as JSON
          try {
            // Store the report data globally for debugging
            reportData = JSON.parse(responseText);
            console.log('Successfully parsed report response as JSON:', reportData.status || 'No status field');
            
            // Check if we got a valid report or an error response
            if (reportData.status === 'error' || !reportData.url) {
              console.warn('Received error response or invalid report data:', reportData);
              
              // Try to access the report directly from R2 with the detailed suffix
              console.log(`Trying direct R2 access: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}-detailed`);
              
              const directResponse = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}-detailed`);
              console.log(`Direct R2 access response status: ${directResponse.status}`);
              
              if (directResponse.ok) {
                const directResponseText = await directResponse.text();
                console.log(`Direct report response text: ${directResponseText.substring(0, 100)}${directResponseText.length > 100 ? '...' : ''}`);
                
                try {
                  const directReportData = JSON.parse(directResponseText);
                  console.log('Successfully parsed direct R2 access response as JSON');
                  
                  if (directReportData.url || directReportData.content || directReportData.features) {
                    reportData = directReportData; // Update global reportData
                    console.log('Successfully loaded report from direct R2 access');
                  } else {
                    console.warn('Direct report data is incomplete:', directReportData);
                    // Try to enhance the report data with what we have
                    reportData = {
                      ...directReportData,
                      url: urlInput.value || taskId,
                      timestamp: directReportData.timestamp || new Date().toISOString()
                    };
                  }
                } catch (directParseError) {
                  console.error('Error parsing direct report response:', directParseError);
                  // Try the original report ID without the -detailed suffix
                  return loadOriginalReport(taskId);
                }
              } else {
                console.error('Failed to access report directly from R2:', directResponse.status);
                
                // Try a different format for the detailed report
                console.log(`Trying direct R2 access with alternative format: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}-detailed.json`);
                
                const altResponse = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}-detailed.json`);
                console.log(`Alternative format response status: ${altResponse.status}`);
                
                if (altResponse.ok) {
                  const altResponseText = await altResponse.text();
                  console.log(`Alternative format response text: ${altResponseText.substring(0, 100)}${altResponseText.length > 100 ? '...' : ''}`);
                  
                  try {
                    const altReportData = JSON.parse(altResponseText);
                    console.log('Successfully parsed alternative format response as JSON');
                    
                    if (altReportData.url || altReportData.content || altReportData.features) {
                      reportData = altReportData; // Update global reportData
                      console.log('Successfully loaded report from alternative format');
                    } else {
                      console.warn('Alternative format report data is incomplete:', altReportData);
                      // Try the original report ID without the -detailed suffix
                      return loadOriginalReport(taskId);
                    }
                  } catch (altParseError) {
                    console.error('Error parsing alternative format response:', altParseError);
                    // Try the original report ID without the -detailed suffix
                    return loadOriginalReport(taskId);
                  }
                } else {
                  console.error('Failed to access report with alternative format:', altResponse.status);
                  // Try the original report ID without the -detailed suffix
                  return loadOriginalReport(taskId);
                }
              }
            }
          } catch (parseError) {
            console.error('Error parsing report response as JSON:', parseError);
            statusMessage.textContent = `Error: Failed to parse report response as JSON. Trying direct access...`;
            
            // Try to access the report directly from R2 with the detailed suffix
            try {
              console.log(`Trying direct R2 access after parse error: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}-detailed`);
              
              const directResponse = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}-detailed`);
              console.log(`Direct R2 access response status after parse error: ${directResponse.status}`);
              
              if (directResponse.ok) {
                const directResponseText = await directResponse.text();
                console.log(`Direct R2 access response text after parse error: ${directResponseText.substring(0, 100)}${directResponseText.length > 100 ? '...' : ''}`);
                
                try {
                  reportData = JSON.parse(directResponseText); // Update global reportData
                  console.log('Successfully loaded report from direct R2 access after initial parse error');
                } catch (directParseError) {
                  console.error('Error parsing direct report response:', directParseError);
                  // Try the original report ID without the -detailed suffix
                  return loadOriginalReport(taskId);
                }
              } else {
                console.error('Failed to access report directly from R2 after initial parse error:', directResponse.status);
                // Try the original report ID without the -detailed suffix
                return loadOriginalReport(taskId);
              }
            } catch (directAccessError) {
              console.error('Error accessing report directly from R2:', directAccessError);
              // Try the original report ID without the -detailed suffix
              return loadOriginalReport(taskId);
            }
          }
          
          // Log the report data for debugging
          console.log('Final report data:', JSON.stringify(reportData, null, 2));
          
          // Format and display the report
          displayReport(reportData);
        } catch (error) {
          console.error('Error loading report:', error);
          statusMessage.textContent = 'Error: Failed to load report. Creating fallback report.';
          
          // Create a fallback report based on the task ID
          reportData = createFallbackReport(taskId);
          
          // Format and display the fallback report
          displayReport(reportData);
        }
      }
      
      // Function to try loading the original report (without -detailed suffix)
      async function loadOriginalReport(taskId) {
        try {
          console.log(`Trying original report ID: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=report&reportId=${taskId}`);
          
          const response = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=report&reportId=${taskId}`);
          console.log(`Original report response status: ${response.status}`);
          
          if (response.ok) {
            const responseText = await response.text();
            console.log(`Original report response text: ${responseText.substring(0, 100)}${responseText.length > 100 ? '...' : ''}`);
            
            try {
              reportData = JSON.parse(responseText);
              console.log('Successfully loaded original report');
              
              // Format and display the report
              displayReport(reportData);
            } catch (parseError) {
              console.error('Error parsing original report response:', parseError);
              
              // Try direct access to R2 with the original taskId (no -detailed suffix)
              console.log(`Trying direct R2 access with original taskId: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}`);
              
              const directResponse = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}`);
              console.log(`Direct R2 access response status: ${directResponse.status}`);
              
              if (directResponse.ok) {
                const directResponseText = await directResponse.text();
                console.log(`Direct R2 access response text: ${directResponseText.substring(0, 100)}${directResponseText.length > 100 ? '...' : ''}`);
                
                try {
                  reportData = JSON.parse(directResponseText);
                  console.log('Successfully loaded report from direct R2 access with original taskId');
                  displayReport(reportData);
                } catch (directParseError) {
                  console.error('Error parsing direct R2 access response:', directParseError);
                  reportData = createFallbackReport(taskId);
                  displayReport(reportData);
                }
              } else {
                console.error('Failed to access report directly from R2 with original taskId:', directResponse.status);
                reportData = createFallbackReport(taskId);
                displayReport(reportData);
              }
            }
          } else {
            console.error('Failed to access original report:', response.status);
            
            // Try direct access to R2 with the original taskId (no -detailed suffix)
            console.log(`Trying direct R2 access with original taskId: /party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}`);
            
            const directResponse = await fetch(`/party/document/api?apiBaseUrl=${encodeURIComponent(apiBaseUrl)}&action=direct-report&reportId=${taskId}`);
            console.log(`Direct R2 access response status: ${directResponse.status}`);
            
            if (directResponse.ok) {
              const directResponseText = await directResponse.text();
              console.log(`Direct R2 access response text: ${directResponseText.substring(0, 100)}${directResponseText.length > 100 ? '...' : ''}`);
              
              try {
                reportData = JSON.parse(directResponseText);
                console.log('Successfully loaded report from direct R2 access with original taskId');
                displayReport(reportData);
              } catch (directParseError) {
                console.error('Error parsing direct R2 access response:', directParseError);
                reportData = createFallbackReport(taskId);
                displayReport(reportData);
              }
            } else {
              console.error('Failed to access report directly from R2 with original taskId:', directResponse.status);
              reportData = createFallbackReport(taskId);
              displayReport(reportData);
            }
          }
        } catch (error) {
          console.error('Error loading original report:', error);
          reportData = createFallbackReport(taskId);
          displayReport(reportData);
        }
      }
      
      // Function to display the report
      function displayReport(reportData) {
        // Update report info
        reportUrl.textContent = reportData.url || reportData.targetUrl || reportData.basicInfo?.url || '-';
        reportDate.textContent = new Date(reportData.timestamp || reportData.analyzedAt || Date.now()).toLocaleString() || '-';
        
        // Format report content for the editor
        let reportContent = '';
        
        if (reportData.title || reportData.basicInfo?.title) {
          reportContent += `# ${reportData.title || reportData.basicInfo?.title}\n\n`;
        }
        
        if (reportData.description) {
          reportContent += `${reportData.description}\n\n`;
        }
        
        reportContent += `## Website Analysis Report\n\n`;
        reportContent += `URL: ${reportData.url || reportData.targetUrl || reportData.basicInfo?.url || 'Unknown URL'}\n`;
        reportContent += `Analyzed: ${new Date(reportData.timestamp || reportData.analyzedAt || Date.now()).toLocaleString()}\n\n`;
        
        // Helper function to format content that might be objects
        const formatContent = (content) => {
          if (typeof content === 'object' && content !== null) {
            if (Array.isArray(content)) {
              return content.map(item => {
                if (typeof item === 'object' && item !== null) {
                  return Object.entries(item)
                    .map(([key, value]) => `**${key.charAt(0).toUpperCase() + key.slice(1)}**: ${formatContent(value)}`)
                    .join('\n');
                }
                return item;
              }).join('\n\n');
            }
            return Object.entries(content)
              .map(([key, value]) => `**${key.charAt(0).toUpperCase() + key.slice(1)}**: ${formatContent(value)}`)
              .join('\n\n');
          }
          return content;
        };
        
        // Add features analysis if available
        if (reportData.features) {
          reportContent += `## Features Analysis\n\n${formatContent(reportData.features)}\n\n`;
        }
        
        // Add pricing analysis if available
        if (reportData.pricing) {
          reportContent += `## Pricing Analysis\n\n${formatContent(reportData.pricing)}\n\n`;
        }
        
        // Add customers analysis if available
        if (reportData.customers) {
          reportContent += `## Target Customers Analysis\n\n${formatContent(reportData.customers)}\n\n`;
        }
        
        // Add content directly if available (from direct R2 access)
        if (reportData.content && !reportData.features) {
          reportContent += `## Content\n\n`;
          // Format the content appropriately
          if (typeof reportData.content === 'object') {
            reportContent += formatContent(reportData.content);
          } else {
            reportContent += `${reportData.content}\n\n`;
          }
        }
        
        // Add metadata if available
        if (reportData.metadata) {
          reportContent += `## Metadata\n\n`;
          reportContent += formatContent(reportData.metadata);
          reportContent += `\n\n`;
        }
        
        // Add performance metrics if available
        if (reportData.performance) {
          reportContent += `## Performance Metrics\n\n`;
          reportContent += formatContent(reportData.performance);
          reportContent += `\n\n`;
        }
        
        // Set the editor content directly first
        document.getElementById('editor').value = reportContent;
        
        // Then try to save to collaborative document
        try {
          saveReportToCollaborativeDoc(reportContent);
        } catch (error) {
          console.warn('Failed to save to collaborative document, but report is still viewable:', error);
        }
      }
      
      // Function to create a fallback report when the API fails
      function createFallbackReport(taskId) {
        // Extract the URL from the task ID if possible
        let url = urlInput.value || 'https://example.com';
        
        // Create a basic report with the information we have
        return {
          url: url,
          title: `Analysis Report for ${url}`,
          description: `This is an automatically generated report for ${url}. The detailed analysis is still being processed.`,
          timestamp: new Date().toISOString(),
          metadata: {
            title: `Website Analysis: ${url}`,
            description: `Analysis of ${url} website content and features.`,
            keywords: 'website, analysis, report'
          },
          analysis: {
            features: 'The detailed feature analysis is still being processed. Please check back later or regenerate the report.',
            pricing: 'Pricing information is not available in this preliminary report.',
            customers: 'Target customer information is not available in this preliminary report.'
          }
        };
      }
      
      // Function to save report to collaborative document
      async function saveReportToCollaborativeDoc(content) {
        try {
          // Set the editor content directly
          if (window.documentEditor) {
            window.documentEditor.setContent(content);
          } else {
            document.getElementById('editor').value = content;
          }
          
          // Try to save to collaborative document
          try {
            const originalText = saveButton.textContent;
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;
            
            const response = await fetch('/party/document', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ content })
            });
            
            if (response.ok) {
              console.log('Report saved to collaborative document');
              saveButton.textContent = 'Saved!';
              document.getElementById('status').textContent = 'Connected';
              document.getElementById('status-indicator').classList.add('status-connected');
              document.getElementById('status-indicator').classList.remove('status-disconnected');
              
              // Reset button after 2 seconds
              setTimeout(() => {
                saveButton.textContent = originalText;
                saveButton.disabled = false;
              }, 2000);
            } else {
              console.warn('Failed to save to collaborative document, but editor is still usable');
              saveButton.textContent = 'Save Failed';
              document.getElementById('status').textContent = 'Error saving document';
              document.getElementById('status-indicator').classList.add('status-disconnected');
              document.getElementById('status-indicator').classList.remove('status-connected');
              
              // Reset button after 2 seconds
              setTimeout(() => {
                saveButton.textContent = originalText;
                saveButton.disabled = false;
              }, 2000);
            }
          } catch (error) {
            console.warn('Error saving to collaborative document, but editor is still usable:', error);
            document.getElementById('save-button').textContent = 'Save Failed';
            document.getElementById('status').textContent = 'Disconnected';
            document.getElementById('status-indicator').classList.add('status-disconnected');
            document.getElementById('status-indicator').classList.remove('status-connected');
            
            // Reset button after 2 seconds
            setTimeout(() => {
              document.getElementById('save-button').textContent = 'Save Report';
              document.getElementById('save-button').disabled = false;
            }, 2000);
          }
        } catch (error) {
          console.error('Error setting up editor:', error);
          statusMessage.textContent = 'Error: Failed to set up editor, but you can still view the report';
        }
      }
      
      // Handle save button click
      saveButton.addEventListener('click', () => {
        let content;
        if (window.documentEditor) {
          content = window.documentEditor.getContent();
        } else {
          content = document.getElementById('editor').value;
        }
        
        saveReportToCollaborativeDoc(content);
      });

      // Toggle debug section
      toggleDebugButton.addEventListener('click', () => {
        const debugSection = document.getElementById('debug-section');
        const rawJson = document.getElementById('raw-json');
        
        if (debugSection.style.display === 'none' || debugSection.style.display === '') {
          debugSection.style.display = 'block';
          if (reportData) {
            rawJson.textContent = JSON.stringify(reportData, null, 2);
          } else {
            rawJson.textContent = 'No report data available yet. Generate a report first.';
          }
          toggleDebugButton.textContent = 'Hide Raw JSON';
        } else {
          debugSection.style.display = 'none';
          toggleDebugButton.textContent = 'Show Raw JSON';
        }
      });
    });
  </script>
</body>
</html>